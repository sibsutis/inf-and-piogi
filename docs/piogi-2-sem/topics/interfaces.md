---
title: "Интерфейсы: база и пример"
secretKey: "12345"
---
# Внимание 

---
*С интерфейсами мы будем активно работать в следующем семестре, НО, так как нам пришлось использовать готовый интерфейс сейчас, я решил добавить часть с объяснением того, что (у вас) здесь происходит(!?).*

---

## Определение.

Интерфейсы в C# — **это контракт, определяющий набор методов, свойств, событий или индексаторов, которые класс должен реализовать**.

Интерфейс представляет ссылочный тип, который может определять некоторый функционал - набор методов и свойств без реализации. Затем этот функционал реализуют классы и структуры, которые применяют данные интерфейсы.

## Простым языком

Глобально интерфейсы могут быть использованы для расширения функционала основного класса. То есть представим что у нас есть класс `Car` и класс `Person`. И мы создали интерфейс `IMovable` в котором объявили метод `Move()`. 
Важно, что мы не реализовываем метод `Move()` в интерфейсе. Метод будет реализован в классе `Car` и классе `Person`. 
И человек и машина могут двигаться, но делают они это по разному.

```csharp
interface IMovable //наш интерфейс
{
    void Move(); //наш метод БЕЗ РЕАЛИЗАЦИИ (НЕТ КОДА В ФИГУРНЫХ СКОБОЧКАХ)
}
```

```csharp
//применение интерфейса в классе
class Person : IMovable
{
    public void Move()
    {
        Console.WriteLine("Человек идет");
    }
}
//применение интерфейса в структуре
struct Car : IMovable
{
    public void Move()
    {
        Console.WriteLine("Машина едет");
    }
}
```

## Зачем?
Главная причина вот какая: **благодаря интерфейсам работать с разными "движущимися" вещами одинаково.**

Представьте, что у нас есть коробка, и мы хотим положить в нее все, что умеет двигаться. Мы можем положить туда `Person` и `Car`. Когда мы хотим, чтобы каждый предмет в коробке "подвигался", мы просто говорим: "Каждый предмет в коробке, выполни свое обещание из интерфейса `IMovable`!"

Мы не говорим: "Эй, Человек, иди" и "Эй, Машина, езжай". Мы просто говорим: "Двигайтесь!", и каждый предмет в коробке сам знает, **как это сделать по-своему**, потому что он выполнил обещание из нашего интерфейса `IMovable`.

## Пояснение по коду с `INotifyPropertyChanged`:

```csharp
public event PropertyChangedEventHandler PropertyChanged;
```

- Это объявление **события** (event) с типом `PropertyChangedEventHandler`.
- **Событие** используется для уведомления других компонентов о том, что какое-то свойство объекта было изменено.
- Тип `PropertyChangedEventHandler` является делегатом, который принимает два параметра:
    1. Источник события (в данном случае объект, который инициировал изменение).
    2. Параметры события, которые содержат имя измененного свойства (тип `PropertyChangedEventArgs`).

```csharp
public void OnPropertyChanged([CallerMemberName] string prop = "")
{
    if (PropertyChanged != null)
        PropertyChanged(this, new PropertyChangedEventArgs(prop));
}
```

- Этот метод используется для **сигнализации об изменении** свойства.
- Атрибут `[CallerMemberName]` используется для автоматической передачи имени свойства, которое вызвало изменение, в параметр `prop`. Это позволяет избежать вручную указывать имя свойства при вызове `OnPropertyChanged` (что удобно при работе с сеттерами).
- Если событие `PropertyChanged` подписано (то есть если есть обработчики), метод вызывает это событие и передает имя измененного свойства.

**Итог:** Когда свойство изменяется, вы вызываете `OnPropertyChanged`, чтобы уведомить всех подписчиков (обычно это графический интерфейс), что свойство обновилось.

### Пример использования:

Предположим, у вас есть свойство `Name`:

```csharp
private string _name;
public string Name
{
    get { return _name; }
    set
    {
        if (_name != value)
        {
            _name = value;
            OnPropertyChanged(); // Здесь вызывается метод, чтобы уведомить об изменении
        }
    }
}
```

Каждый раз, когда свойство `Name` изменяется, вызывается `OnPropertyChanged`, чтобы уведомить всех подписчиков (например, интерфейс), что значение свойства изменилось. 

**Без реализации этого интерфейса измененные данные в модели (объекте класса, например) могут не измениться в графическом интерфейсе.**
### Зачем это нужно?

- Данный интерфейс позволяет легко синхронизировать данные между моделью и представлением, особенно в приложениях с привязкой данных (например, в WPF, Xamarin, или UWP).
- Также упрощает обновление UI, так как он автоматически обновляется, когда данные изменяются.