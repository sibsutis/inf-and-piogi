---
title: Основа по xaml
tags:
doc-type:
  - topic
doc-status:
---

# Основа по XAML (WPF)

### Суть XAML.
В отличие от HTML, который является языком разметки гипертекста (инструкция браузеру, как рисовать), XAML — это **декларативное описание создания объектов .NET**.

Когда вы пишете тег в XAML, парсер WPF делает ровно то же самое, что вы делали бы в C#, но визуально проще.

*   **XAML:** `<Button Width="100" />`
*   **C# эквивалент:**
    ```csharp
    var btn = new Button();
    btn.Width = 100;
    ```

**[СКРИН: Слева код XAML с кнопкой, справа эквивалентный C# код создания этой же кнопки]**

### 2. Иерархия и Вложенность (Древовидная структура)
В WPF всё строится на иерархии расположения элементов. Это называется **Visual Tree** (Визуальное дерево).

!!! note
*   Есть **Корневой элемент** (обычно `Window` или `Page`). У окна может быть только *один* прямой потомок (Child).
*   Внутри этого потомка вкладываются другие элементы.
*   Отношения «Родитель — Ребенок» определяют, как элементы располагаются и наследуют свойства (например, шрифт).

Пример структуры:
```xml
<Window>               <!-- Корень -->
    <Grid>             <!-- Контейнер компоновки (Родитель) -->
        <Button />     <!-- Ребенок 1 -->
        <TextBox />    <!-- Ребенок 2 -->
    </Grid>
</Window>
```

**[СКРИН: Схема дерева объектов: Window -> Grid -> [Button, TextBox]. Визуализация вложенности]**

### 3. Атрибуты = Свойства
То, что в HTML выглядит как атрибут (`<div class="...">`), в XAML является прямой записью значения в **Свойство (Property)** класса.

*   Пишем `<Button Content="Нажми меня" Background="Blue" />`
*   Это означает: `Button.Content = "Нажми меня"; Button.Background = Brushes.Blue;`

**Важное отличие от HTML:**
XAML строго типизирован. Если свойство ожидает число (`Width="100"`), вы не можете передать туда текст, который парсер не сможет преобразовать. Если свойство ожидает сложный объект (например, градиентную кисть), используется синтаксис «Свойство-Элемент» (развернутый вид):

```xml
<Button>
    <Button.Background>
        <!-- Сложная настройка свойства Background -->
        <SolidColorBrush Color="Red" />
    </Button.Background>
</Button>
```

**[СКРИН: Пример кнопки, где одно свойство задано атрибутом (текст), а другое развернуто тегом (цвет/градиент)]**

### 4. Пространства имен (Namespaces) — `xmlns`
В HTML теги `<div>`, `<span>` работают сразу. В XAML (как и в C# с `using`) нужно сказать компилятору, где лежат классы этих тегов.

Вы увидите это в корневом теге:
```xml
<Window x:Class="MyApp.MainWindow"
        xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
        xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml">
```

*   `xmlns="..."` (без префикса) — это дефолтное пространство. Все стандартные элементы WPF (Grid, Button, StackPanel) лежат здесь. Поэтому мы пишем просто `<Grid>`, а не `<wpf:Grid>`.
*   `xmlns:x="..."` — это служебное пространство XAML. Оно нужно для уникальных ключей, имен объектов и настройки компиляции.
*   Если вы захотите использовать свой кастомный элемент управления, вам придется добавить свою строку `xmlns:local="clr-namespace:MyApp"`.

**[СКРИН: Подсветка строк xmlns в коде с выносками: "Базовые контролы WPF" и "Служебные инструменты XAML"]**

### 5. Связь с логикой (`x:Class`)
Как XAML-файл узнает, где лежит его C# код (обработчики нажатий и логика)?
Через атрибут `x:Class` в корневом элементе.

*   **XAML:** `<Window x:Class="MyProject.MainWindow" ...>`
*   **C#:** `public partial class MainWindow : Window { ... }`

Ключевое слово `partial` (частичный класс) в C# позволяет "склеить" ваш код и код, сгенерированный из XAML, в один класс при компиляции.

**[СКРИН: Разделенный экран: слева XAML файл со стрелкой от x:Class, справа C# файл с классом MainWindow]**