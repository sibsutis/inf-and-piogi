---
title: Лекция 2 - Архитектура клиент-серверных приложений
doc-status:
  - in_work
doc-type:
  - lection
---

# Архитектура клиент-серверных приложений

## Введение

Когда вы открываете приложение погоды на телефоне — откуда берутся данные о температуре? Когда листаете ленту в соцсети — где хранятся все эти посты и фото? Когда бронируете билеты в кино — кто проверяет, что место ещё свободно?

Ответ: **сервер**. А ваше приложение — это **клиент**, который общается с сервером.

Понимание архитектуры клиент-сервер — фундамент для любого современного разработчика.

---

## Эволюция архитектур приложений

### Монолитные приложения (1960-90-е)

В начале всё было просто: одна программа делает всё. База данных, логика, интерфейс — всё в одном месте.

```
┌─────────────────────────────┐
│       Монолит               │
│  ┌───────────────────────┐  │
│  │   Пользовательский    │  │
│  │      интерфейс        │  │
│  ├───────────────────────┤  │
│  │   Бизнес-логика       │  │
│  ├───────────────────────┤  │
│  │   База данных         │  │
│  └───────────────────────┘  │
└─────────────────────────────┘
```

**Плюсы:** Просто разрабатывать, просто деплоить.

**Минусы:** Сложно масштабировать, один баг может положить всё приложение, сложно работать командой.

### Клиент-сервер (1990-2000-е)

Разделение на две части: клиент (интерфейс) и сервер (логика + данные).

```
┌─────────────┐         ┌─────────────┐
│   Клиент    │◀───────▶│   Сервер    │
│  (UI)       │  HTTP   │  (Логика +  │
│             │         │   База)     │
└─────────────┘         └─────────────┘
```

Это то, что мы будем делать в курсе: WPF-приложение (клиент) общается с API (сервер).

### Трёхуровневая архитектура

Более продвинутый вариант — выделение базы данных в отдельный слой:

```
┌─────────────┐     ┌─────────────┐     ┌─────────────┐
│   Клиент    │────▶│   Сервер    │────▶│   База      │
│  (WPF App)  │     │   (API)     │     │  (SQL)      │
└─────────────┘     └─────────────┘     └─────────────┘
   Presentation       Business           Data
      Layer             Layer            Layer
```

### Микросервисы (2010-е+)

Современный подход для больших систем — разбить сервер на множество маленьких независимых сервисов:

```
                    ┌──────────────┐
                    │   Gateway    │
                    └──────┬───────┘
           ┌───────────────┼───────────────┐
           ▼               ▼               ▼
    ┌─────────────┐ ┌─────────────┐ ┌─────────────┐
    │   Users     │ │   Movies    │ │   Booking   │
    │   Service   │ │   Service   │ │   Service   │
    └──────┬──────┘ └──────┬──────┘ └──────┬──────┘
           │               │               │
        ┌──▼──┐         ┌──▼──┐         ┌──▼──┐
        │ DB1 │         │ DB2 │         │ DB3 │
        └─────┘         └─────┘         └─────┘
```

Каждый сервис можно разрабатывать, деплоить и масштабировать независимо.

---

## HTTP под капотом

### Как работает интернет

Когда вы вводите адрес в браузере, происходит много всего (мы не будем рассматривать транспортные уровни):

```
1. Вы вводите: https://api.cinema.com/movies
                    │
2. DNS-запрос: "Какой IP у api.cinema.com?"
                    │
                    ▼
3. DNS-сервер отвечает: 203.0.113.42
                    │
4. TCP-соединение с 203.0.113.42:443
                    │
5. HTTP-запрос: GET /movies
                    │
6. HTTP-ответ: [{"id":1,"title":"Мстители"...}]
```

### Структура HTTP-запроса

```http
GET /api/movies HTTP/1.1
Host: api.cinema.com
Accept: application/json
Authorization: Bearer eyJhbGciOiJIUzI1NiIs...
```

- **Метод** (GET, POST, PUT, DELETE) — что хотим сделать
- **Путь** (/api/movies) — с каким ресурсом
- **Заголовки** — метаданные запроса
- **Тело** (для POST/PUT) — передаваемые данные

### Структура HTTP-ответа

```http
HTTP/1.1 200 OK
Content-Type: application/json
Content-Length: 245

[
  {"id": 1, "title": "Мстители", "duration": 143},
  {"id": 2, "title": "Интерстеллар", "duration": 169}
]
```

- **Статус-код** (200, 404, 500) — результат операции
- **Заголовки** — метаданные ответа
- **Тело** — данные

### HTTP-методы

| Метод | Назначение | Пример |
|-------|------------|--------|
| **GET** | Получить данные | Список фильмов |
| **POST** | Создать ресурс | Новое бронирование |
| **PUT** | Заменить ресурс | Обновить профиль |
| **PATCH** | Частично изменить | Изменить email |
| **DELETE** | Удалить | Отменить бронь |

### Коды состояния HTTP

| Диапазон | Значение | Примеры |
|----------|----------|---------|
| **2xx** | Успех | 200 OK, 201 Created |
| **3xx** | Перенаправление | 301 Moved, 304 Not Modified |
| **4xx** | Ошибка клиента | 400 Bad Request, 404 Not Found |
| **5xx** | Ошибка сервера | 500 Internal Error, 503 Service Unavailable |

---

## Что такое API

==Сюда впихнуть про другие программные интерфейсы консоль и гуи==

### Определение

**API (Application Programming Interface)** — это контракт между двумя программами. Он определяет:

- Какие запросы можно отправлять
- В каком формате отправлять данные
- Какие ответы ожидать

Представьте ресторан:
- **Меню** — это API (описание того, что можно заказать)
- **Официант** — это HTTP (передаёт ваш заказ на кухню)
- **Кухня** — это сервер (готовит заказ)
- **Вы** — это клиент (делаете заказ)

### API-first подход

Современная разработка часто начинается с проектирования API:

1. Команда договаривается о контракте (какие эндпоинты, какие данные)
2. Frontend (наше приложение на WPF) и Backend (сервер с фильмами) могут работать параллельно
3. Frontend использует **моки (заглушки)** пока Backend не готов
4. Когда обе части готовы — они уже совместимы

### Swagger/OpenAPI

**OpenAPI** (ранее Swagger) — стандарт описания REST API:

```yaml
paths:
  /movies:
    get:
      summary: Получить список фильмов
      responses:
        200:
          description: Список фильмов
          content:
            application/json:
              schema:
                type: array
                items:
                  $ref: '#/components/schemas/Movie'
```

По такому описанию можно автоматически генерировать документацию и даже клиентский код.

---

## REST vs GraphQL vs gRPC

### REST (Representational State Transfer)

**REST** — самый распространённый стиль API. Принципы:

- Ресурсы идентифицируются URL (`/movies`, `/movies/1`)
- Используются HTTP-методы (GET, POST, PUT, DELETE)
- Stateless — сервер не хранит состояние клиента

```
GET /movies              → Список фильмов
GET /movies/1            → Фильм с id=1
POST /movies             → Создать фильм
PUT /movies/1            → Обновить фильм
DELETE /movies/1         → Удалить фильм
```

**Плюсы:** Простота, кеширование, стандартизация.
**Минусы:** Over-fetching (получаем лишние данные), Under-fetching (нужно несколько запросов).

### GraphQL

**GraphQL** — язык запросов от Facebook. Клиент сам указывает, какие поля нужны:

```graphql
query {
  movie(id: 1) {
    title
    duration
    sessions {
      time
      availableSeats
    }
  }
}
```

**Плюсы:** Получаем ровно то, что нужно, один запрос вместо многих.
**Минусы:** Сложнее в реализации, проблемы с кешированием.

### gRPC

**gRPC** — протокол от Google на основе Protocol Buffers. Бинарный формат, очень быстрый.

**Плюсы:** Высокая производительность, строгая типизация.
**Минусы:** Не работает напрямую в браузере, сложнее отлаживать.

### Что использовать?

| Сценарий | Рекомендация |
|----------|--------------|
| Обычное веб/мобильное приложение | REST |
| Сложный UI с разными данными | GraphQL |
| Микросервисы, высокие нагрузки | gRPC |
| Учебный проект | REST (то, что мы делаем) |

---

## JSON — язык данных интернета

### Почему JSON?

**JSON (JavaScript Object Notation)** стал стандартом обмена данными в вебе:

- Читаемый человеком
- Легко парсится любым языком
- Компактнее XML
- Нативная поддержка в JavaScript

### Структура JSON

```json
{
  "id": 1,
  "title": "Мстители",
  "duration": 143,
  "genres": ["Action", "Sci-Fi"],
  "director": {
    "name": "Джосс Уидон",
    "birthYear": 1964
  },
  "isReleased": true,
  "rating": null
}
```

**Типы данных:**
- Строки: `"text"`
- Числа: `42`, `3.14`
- Булевы: `true`, `false`
- Null: `null`
- Массивы: `[1, 2, 3]`
- Объекты: `{"key": "value"}`

### JSON vs XML

**XML:**
```xml
<movie>
  <id>1</id>
  <title>Мстители</title>
  <duration>143</duration>
</movie>
```

**JSON:**
```json
{
  "id": 1,
  "title": "Мстители",
  "duration": 143
}
```

JSON в 2 раза короче и проще читается. Поэтому современные API используют JSON.

==Вставить прикол про усы и новый формат для нейронок которой очень похож.==

---

## Проблемы распределённых систем

### Fallacies of Distributed Computing

Классические заблуждения о распределённых системах:

1. **Сеть надёжна** — Нет. Соединения рвутся, пакеты теряются.
2. **Задержка нулевая** — Нет. Запрос может идти 10мс или 10с.
3. **Пропускная способность бесконечна** — Нет. Каналы забиваются.
4. **Сеть безопасна** — Нет. Данные могут перехватить.
5. **Топология не меняется** — Нет. Серверы добавляются и удаляются.
6. **Есть один администратор** — Нет. У каждого сервиса свой владелец.
7. **Транспортировка бесплатна** — Нет. Трафик стоит денег.
8. **Сеть однородна** — Нет. Разные устройства, разные скорости.

### CAP-теорема (упрощённо) (нужно разжевать)

В распределённой системе можно гарантировать только 2 из 3:

- **Consistency** (Согласованность) — все видят одинаковые данные
- **Availability** (Доступность) — система всегда отвечает
- **Partition tolerance** (Устойчивость к разделению) — система работает при проблемах сети

```
         Consistency
            /\
           /  \
          /    \
         /  ??  \
        /________\
Availability    Partition
                tolerance
```

Реальный пример: бронирование билетов. Если два человека одновременно бронируют одно место — что важнее: чтобы оба получили ответ быстро (Availability) или чтобы место досталось только одному (Consistency)?

### Eventual Consistency (тоже разжевать)

Компромиссное решение: данные **в конечном итоге** станут согласованными, но в какой-то момент разные клиенты могут видеть разные данные.

Пример: вы добавили пост в соцсеть. Ваш друг в другом городе увидит его через 2 секунды, не мгновенно. Это eventual consistency.

---

## Связь с лабораторной работой

### Что вы сделаете в Лабе 2

В лабораторной работе 2 вы:

1. **Создадите HTTP-клиент** — класс `ApiService` с `HttpClient`
2. **Отправите GET-запрос** — к эндпоинту `/api/movies`
3. **Десериализуете JSON** — превратите строку в объекты C#
4. **Отобразите данные** — в ListBox появятся реальные фильмы

### Почему мы читаем с API, а не из файла

| Файл | API |
|------|-----|
| Данные устаревают | Данные всегда актуальные |
| Нужно обновлять вручную | Обновляются автоматически |
| Ограничен одним устройством | Доступен отовсюду |
| Нет синхронизации | Все видят одни данные |
==добавить градацию оценок для дизайнеров (из готового файла) и программистов (по апи). Лучше серебро-золото для файл-апи.==

Наше WPF-приложение — это клиент, который запрашивает данные у сервера. Точно так же работают все современные приложения: от мессенджеров до банкинга.

---

## Заключение

Клиент-серверная архитектура — это **фундамент современного ПО**:

- Разделение ответственности (UI отдельно, логика отдельно)
- Масштабируемость (можно добавлять серверы)
- Независимая разработка (frontend и backend работают параллельно)
- Кроссплатформенность (один API — много клиентов)

Понимание HTTP, REST и JSON — это **must-have** для любого разработчика. Эти знания применимы везде: веб, мобильная разработка, IoT, игры.

---

## Полезные ресурсы

- [MDN: HTTP](https://developer.mozilla.org/ru/docs/Web/HTTP) — подробная документация
- [REST API Tutorial](https://restfulapi.net/) — принципы REST
- [JSON.org](https://www.json.org/json-ru.html) — спецификация JSON
- [Postman](https://www.postman.com/) — инструмент для тестирования API
