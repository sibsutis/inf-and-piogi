---
title: Лекция 1 - Зачем нужен Git и как работать в команде
doc-status:
  - in_work
doc-type:
  - lection
---

# Зачем нужен Git и как работать в команде

## Введение

Представьте, что вы пишете курсовую работу. Сначала у вас файл `курсовая.docx`. Потом вы вносите правки и сохраняете как `курсовая_v2.docx`. Потом научный руководитель просит переделать — появляется `курсовая_финал.docx`. Потом `курсовая_финал_исправленный.docx`. Потом `курсовая_СДАВАТЬ_ТОЧНО.docx`.

Знакомо? Это называется **"версионирование через копирование"** — и это худший способ управлять изменениями.

А теперь представьте, что над проектом работают 5 человек. Каждый делает свою копию. Кто-то забыл отправить свои изменения. Кто-то перезаписал чужую работу. Хаос.

**Git** решает эту проблему раз и навсегда.

---

## История контроля версий

### Эпоха "папок и копий" (до 1970-х)

Программисты буквально копировали папки с кодом и называли их по датам или версиям. Никакой автоматизации, никакой истории изменений.

### Локальные системы (1970-80-е)

Появились первые системы контроля версий, которые хранили историю изменений на локальном компьютере. Проблема: работать вместе было невозможно.

### Централизованные системы (1990-2000-е)

**CVS** и **SVN (Subversion)** — все изменения хранились на центральном сервере. Плюсы: можно работать командой. Минусы: если сервер упал — все встали. Нет интернета — нет работы.

```
         ┌─────────────┐
         │   Сервер    │
         │   (SVN)     │
         └──────┬──────┘
                │
    ┌───────────┼───────────┐
    │           │           │
┌───▼───┐   ┌───▼───┐   ┌───▼───┐
│ Dev 1 │   │ Dev 2 │   │ Dev 3 │
└───────┘   └───────┘   └───────┘
```

### Распределённые системы (2005+)

**Git** изменил правила игры. Каждый разработчик имеет **полную копию** репозитория со всей историей. Можно работать офлайн, можно синхронизироваться с любым количеством серверов.

```
┌─────────────┐     ┌─────────────┐     ┌─────────────┐
│   Dev 1     │────▶│   GitHub    │◀────│   Dev 2     │
│ (полная     │     │ (remote)    │     │ (полная     │
│  история)   │◀────│             │────▶│  история)   │
└─────────────┘     └─────────────┘     └─────────────┘
                           ▲
                           │
                    ┌──────┴──────┐
                    │   Dev 3     │
                    │ (полная     │
                    │  история)   │
                    └─────────────┘
```

---

## Почему Git победил

Git был создан **Линусом Торвальдсом** в 2005 году для разработки ядра Linux. Почему именно Git стал стандартом?

### 1. Скорость

Git работает локально. Создание ветки, коммит, просмотр истории — всё происходит мгновенно, без обращения к серверу.

### 2. Надёжность

Каждый клон репозитория — это полный бэкап. Даже если сервер сгорит, любой разработчик может восстановить проект.

### 3. Ветвление

В SVN создание ветки — дорогая операция (копирование всех файлов). В Git ветка — это просто указатель на коммит. Создание ветки занимает миллисекунды.

### 4. Целостность данных

Git использует SHA-1 хеши для идентификации всего: файлов, коммитов, деревьев. Невозможно изменить файл или историю без изменения хеша. Любая порча данных будет обнаружена.

---

## Основные концепции Git

### Репозиторий (Repository)

**Репозиторий** — это папка с вашим проектом + скрытая папка `.git`, где хранится вся история изменений.

```
МойПроект/
├── .git/           ← История, ветки, настройки
├── src/
│   └── App.cs
├── README.md
└── .gitignore
```

### Коммит (Commit)

**Коммит** — это "снимок" состояния проекта (файлов и папок) в определённый момент времени. Каждый коммит содержит:

- Уникальный идентификатор (SHA-1 хеш)
- Автора и дату
- Сообщение с описанием изменений
- Ссылку на родительский коммит

```
commit a1b2c3d4e5f6...
Author: Ivan Ivanov <ivan@example.com>
Date:   Mon Jan 15 14:30:00 2024

    feat: add user authentication
```

### Ветка (Branch)

**Ветка** — это независимая линия разработки. По умолчанию создаётся ветка `main` (или `master`). ==Вот тут надо добавить примеры==

```
          feature/login
              │
    ┌────────▼────────┐
    │   C4 ── C5      │
    │  /              │
C1──C2──C3────────────C6  ← main
              ▲
              └── merge
```

### Слияние (Merge)

**Merge** — объединение изменений из одной ветки в другую.

---

## Психология командной работы

### Merge Conflicts — это нормально

**Конфликт слияния** возникает, когда два человека изменили одну и ту же строку кода. Git не знает, чью версию оставить, и просит вас решить.

```
<<<<<<< HEAD
int result = a + b;
=======
int result = a * b;
>>>>>>> feature/multiply
```

**Конфликты — это не ошибка.** Это способ Git сказать: "Эй, тут нужно человеческое решение."

### Почему конфликты полезны

1. **Заставляют общаться.** Если два разработчика меняют один и тот же код — возможно, они решают одну задачу по-разному. Конфликт — повод обсудить.

2. **Выявляют проблемы архитектуры.** Частые конфликты в одном файле = файл слишком большой или делает слишком много.

3. **Учат читать чужой код.** Разрешая конфликт, вы вынуждены понять, что делал коллега.

---

## DevOps культура и Git

### CI/CD — Непрерывная интеграция и доставка

Современные команды используют **CI/CD pipelines** — автоматические процессы, которые запускаются при каждом push:

```
Push → Build → Test → Deploy
```

1. **Continuous Integration (CI):** Каждый push автоматически собирает проект и запускает тесты.
2. **Continuous Deployment (CD):** Успешно протестированный код автоматически разворачивается на сервере.

### Feature Branches vs Trunk-Based Development

**Feature Branches** (что мы используем в курсе):
- Каждая задача = отдельная ветка
- Ветка живёт пока задача не готова
- Merge через Pull Request

```
main ────────────────────────────────▶
       \                    /
        └── feature/task-1 ┘
```

**Trunk-Based Development** (для опытных команд):
- Все работают в `main`
- Коммиты маленькие и частые
- Feature flags для незавершённых функций

---

## Профессиональные практики

### Conventional Commits

**Conventional Commits** — стандарт оформления сообщений коммитов:

```
<тип>: <описание>

[необязательное тело]

[необязательный футер]
```

**Типы:**

| Тип        | Описание                                           |
| ---------- | -------------------------------------------------- |
| `feat`     | Новая функциональность                             |
| `fix`      | Исправление бага                                   |
| `docs`     | Изменения в документации                           |
| `style`    | Форматирование, пробелы, точки с запятой           |
| `refactor` | Рефакторинг без изменения поведения                |
| `test`     | Добавление или исправление тестов                  |
| `chore`    | Обновление зависимостей, настройка сборки, рутина  |

**Примеры:**

```
feat: add movie search functionality
fix: resolve crash on empty API response
docs: update README with setup instructions
style: format XAML according to guidelines
refactor: extract HTTP client to separate service
```

### Semantic Versioning (SemVer)

Версии программ записываются как `MAJOR.MINOR.PATCH`:

- **MAJOR** — несовместимые изменения API (серьезное изменение функционала программы) 
- **MINOR** — новая функциональность, обратно совместимая (не ломает старый функционал)
- **PATCH** — исправления багов

```
1.0.0 → 1.0.1 (patch: исправлен баг)
1.0.1 → 1.1.0 (minor: добавлена новая функция)
1.1.0 → 2.0.0 (major: изменён API)
```

### CHANGELOG

**CHANGELOG.md** — файл с историей изменений для пользователей:

```markdown
# Changelog

## [1.2.0] - 2024-01-20

### Added
- Поддержка тёмной темы
- Фильтрация фильмов по жанру

### Fixed
- Исправлена ошибка загрузки изображений

### Changed
- Обновлён дизайн карточки фильма
```

---

## Git в реальных проектах

### Почему Open Source использует Git

Посмотрите на любой крупный проект:
- **Linux Kernel** — 1 000 000+ коммитов, 20 000+ контрибьюторов (даже если кто то просто исправил опечатку в доках, он считается со разработчиком)
- **VS Code** — 150 000+ коммитов
- **.NET Runtime** — 100 000+ коммитов

Git позволяет тысячам людей работать над одним проектом без хаоса.

### Что видно по истории коммитов

История коммитов — это **рентген проекта**:

- Равномерные коммиты в течение 2 недель = постепенная работа
- Один огромный коммит в 4 утра перед дедлайном = ??? 
- Сообщения типа "fix", "asdasd", "111" = небрежное отношение
- Чёткие conventional commits = профессионализм

---

## Связь с лабораторной работой

### Что вы сделаете в Лабе 1

1. **Создадите репозиторий** — ваш проект будет под контролем версий с первого дня
2. **Настроите .gitignore** — научитесь не засорять репозиторий мусором
3. **Сделаете первый коммит** — начало истории вашего проекта
4. **Пригласите преподавателя** — код-ревью как в реальной работе

### Почему это важно сделать в начале

- Вся история разработки будет сохранена
- Можно откатиться к любой рабочей версии
- Преподаватель видит процесс работы, а не только результат
- Вы учитесь работать "как на настоящей работе"

---

## Заключение

Git — это не просто инструмент. Это **образ мышления**:

- История изменений важна
- Маленькие, атомарные изменения лучше больших
- Описывать свои действия — уважение к себе будущему и к коллегам
- Работа в команде требует дисциплины

Те, кто освоит Git на первом курсе, получат огромное преимущество при трудоустройстве. Это **must-have** навык для любого разработчика.

---

## Полезные ресурсы

- [Pro Git Book](https://git-scm.com/book/ru/v2) — бесплатная книга от создателей Git
- [Learn Git Branching](https://learngitbranching.js.org/) — интерактивный тренажёр
- [Conventional Commits](https://www.conventionalcommits.org/) — спецификация
- [GitHub Docs](https://docs.github.com/ru) — документация GitHub на русском
