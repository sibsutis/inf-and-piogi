
## Блок 0: зачем мы это вообще делаем
*(Хоть в задании об этом написано, но)*
В лабе 5 у некоторых студентов появился вопрос: "а мы это все зачем вообще делаем? Есть же готовый, он работает и тд".

### Лаба 5

Сейчас мы с вами в роли **пользователей** кода (в смысле класса `List`), так как мы осваиваем особенности языка. Это чужой чей-то код и мы совершенно не знаем как именно он работает. Но проделав работу по декомпозиции класса (да я сделал это за вас и дал готовый по сути план) и написанию своего, вы приблизились к роли **разработчиков**. Это не значит, что перед использованием какой то библиотеки нужно писать ее с нуля самому, но залезть в документацию или хотя бы в гайды и посмотреть как она работает нужно, иначе как вы можете быть уверенны в том, что код в принципе работает (*или никуда не сливает ваши данные?*).
Написав свой список вы знаете что такое `Resize`, что такое сдвиг списка и вы понимаете механику работы с сдвигами массивов при вставке в начало например.
Если вы не понимаете как работает функционал внутри - вы будете писать неэффективный и тормозной код. 

Ну и в идеале вы знаете что "бесконечных" списков теперь не бывает.

### Лаба 6

>Окей, данные храним умеем понимаем, а зачем нам этот "польский калькулятор" если есть калькулятор буквально в кармане или класс `DataTable` - он умеет строку считать.

А что происходит когда вы пишете `table.Compute("2+2")` ?

Лаба 6 не про математику 2+2. Лаба про то, как передавать понятные для человека наборы символов в комп и выполнять их.

Скриптовые языки, компиляторы, разметка, для этого используются **парсеры**. Данные из одного формата понятной человеческой строки, переходят в другой формат записи (мб кто то слышал про JSON).

В этой лабе мы рассмотрим алгоритм обработки.

## Блок 1: как считает комп

Итак, в чем проблема выражения `2+2*2`? Для нас, людей, никакой проблемы нет. Мы знаем про приоритеты операций в выражениях, скобки и тд. Компьютер не видит все выражению сразу, и для вычисления результата выражения в привычной нам записи мы придем к огромному количеству запутанного кода `if-else`.

И нам нужно использовать другой способ записи математики. Без приоритетов и скобок. То есть где все операнды (числа) и операции будут записаны в одну очередь.

## Блок 2: Обратная Польская Нотация

[**Обратная польская запись**, **постфиксная нотация**](https://ru.wikipedia.org/wiki/Обратная_польская_запись) (запись) — форма записи математических и логических выражений, в которой операнды расположены перед знаками операций. Также именуется как _обратная бесскобочная запись_, _постфиксная нотация_, _бесскобочная символика Лукасевича_, _польская инверсная запись_, _ПОЛИЗ_.

**Суть:** операнды (числа) идут сначала, а оператор в конце.
   
```
3 + 4 --> 3 4 +
(3 + 4) * 5 --> 3 4 + 5 *
```

### Инфиксная запись

**Инфиксная запись** (инфиксная нотация) — форма записи математических и логических формул, в которой **операторы (сложение, вычитание, умножение и деление) записываются между операндами** (числами, переменными, функциями и другими математическими объектами).

Эта запись естественна для человека, но **компьютеру сложнее разобрать её** по сравнению с префиксной (операторы находятся перед операндами) или постфиксной (оператор находится после операндов).

Пример:
```
2+2*2
```


### Префиксная запись

**Префиксная запись (польская нотация)** — форма записи логических, арифметических и алгебраических выражений, в которой **оператор располагается слева от операндов**. В отличие от инфиксной нотации, где операторы находятся между операндами.

```
Было: 2+2*2
Стало: + 2 * 2 2
```

### Постфиксная запись

**Постфиксная (обратная польская) запись** — форма записи математических и логических выражений, в которой **знак операции записывается не между операндами, а после операндов**. Также именуется как обратная бесскобочная запись, постфиксная нотация.

```
Было: 2+2*2
Стало: 2 2 * 2 +
```


### А мы что используем?

Оба варианта (Префиксная a.k.a **Польская** и Постфиксная a.k.a **Обратная Польская**) избавляют от скобок.

- Префикс: + 2 * 2 2
- Постфикс: 2 2 * 2 +

На первый взгляд может показаться, что разница тут не сильно почувствуется, просто зеркально? **НЕТ.**  
Разница в том, как мы (ну и наш процессор) читает данные.

### Считаем префиксную

Итак, чтобы посчитать результат выражения нам нужно идти по нему слева направо.

Выражение `+ 2 * 2 2`

>Начинаем с `+`. Окей нужно сложить. А что с чем? Идем дальше, получаем операнд 2, окей, дальше... умножение... Хорошо, теперь значит берем 2, после еще 2, какая операция была?

1. Читаем `+`. Это команда. Но где данные? Их нет. Они будут "где-то там" в будущем.
2. Нам нужно запомнить этот плюс (положить в стек операторов или уйти в рекурсию) и ждать.
3. Читаем `2`. Это первое число.
4. Читаем `*`. Это команда. Но где данные? Их нет. Они будут "где-то там" в будущем.
5. Читаем `2`. Это первое число.
6. Читаем `2`. Это второе число.
7. А теперь надо "вспомнить", что там было умножение.
8. А потом еще и для плюса...

**Вердикт:**  
Префиксную запись (польскую) прекрасно читают рекурсивным спуском слева направо, но для нас это неактуально, потому что мы не знаем глубину вложенности заранее. Мы будем использовать простой линейный проход.
Чтобы посчитать Префиксную запись простым алгоритмом, нам нужно читать строку **справа налево** (с конца).  
А чтобы читать с конца, нам нужно сначала **загрузить всю строку в память**.  
Постфикс (ОПН) же позволяет считать "на лету", байт за байтом, не зная, когда строка закончится. Это stream processing подход.


### Считаем постфиксную

Выражение то же, запись другая.
`2 2 * 2 +`

1. Читаем `2`. Это данные? Да. В стек.
2. Читаем `2`. Это данные? Да. В стек.
3. Читаем `*`. Это команда? Да. Данные для неё **УЖЕ** лежат в стеке (мы их только что прочли). 
4. Посчитали, результат (`4`) кладем обратно в строку (получится строка `4 2 +`)
5. Читаем `4` в стек.
6. Читаем `2` в стек.
7. Читаем `+`. Считаем результат, кладем в строку.
8. Это конец, в этой же строке будет ответ.

---

## Блок 3: список в стек

В прошлой лабе вы, мученики, писали свой `List<T>`. Зачем? Чтобы понять, что под капотом.

### Стек

В данной работе нам понадобится новая структура данных - **стек**. Стек работает по принципу `LIFO`.
Принцип **LIFO** (Last In, First Out).
>Аналогия: Стопка тарелок. Положил грязную сверху — помыл первую сверху. Нельзя вытащить нижнюю, не разбив всё (да нельзя без НО).
    
### Основные методы
- `Push` (положить В КОНЕЦ), 
- `Pop` (взять С КОНЦА и удалить), 
- `Peek` (подсмотреть).

>Да, технически мы можем использовать тот функционал что есть у нас у списка. Но тогда вместо программирования сортировки и вычисления мы будем заниматься "доставанием последнего элемента из списка" и "добавлением в конец". Всю эту логику мы сразу можем и должны определить в новом классе `Stack<T>`.

### **Генерики (`<T>`)**

Почему `Stack<T>`, а не `StackInt`?
    
Потому что в одной части лабы нам нужен `Stack<double>` (для чисел), а в другой — `Stack<char>` (для плюсиков и минусиков).


## Блок 4: вычислитель записи ОПН

### **Механика**
Идем по строке слева направо. Для вычисления нам нужен 1 стек для чисел.
1. Видим **число** -> `Push` в стек.
2. Видим **знак** -> Делаем `Pop` два раза (достаем два последних числа), считаем, результат -> `Push` обратно.
3. В конце в стеке останется одно число. Это ответ.

### Демо

`3 4 + 2 *` - на доске

>А зачем нам стек если хватит 2ух переменных?

Выражение: `2 + 3 * 4`
В ОПН это: `2 3 4 * +` - тож на доску

## Блок 5: Алгоритм сортировочной станции
Алгоритм предложен Эдсгером Дейкстрой в 1961 году.

Как нам перевести строку `3 + 4 * 2`.

### Входные данные

1. **input**: Строка (или массив строк), содержащая инфиксное выражение. Токены уже разделены.
    - Пример: `["3", "+", "4", "*", "2"]`
2. **output**: Список (или строка), куда мы записываем результат. В начале пуст.
3. **stack**: Стек символов (или строк) для хранения операторов. В начале пуст.

### Таблица приоритетов (Веса операторов)

| Оператор | Приоритет | Описание                                       |
| -------- | --------- | ---------------------------------------------- |
| (        | **0**     | Нижайший (барьер)                              |
| )        | **-**     | Не имеет приоритета, это команда на исполнение |
| +, -     | **1**     | Низкий                                         |
| *, /     | **2**     | Средний                                        |

### Пошаговая инструкция

Мы читаем `input` слева направо, токен за токеном.

#### **Ситуация 1: Токен — Число**

- **Действие:** Сразу добавляем в output.
- **Стек:** Не трогаем.   
- **Логика:** Операнды в ОПН сохраняют свой относительный порядок. Если в исходнике 3 шла перед 4, то и в ОПН 3 будет перед 4.

#### **Ситуация 2: Токен — Открывающая скобка (**

- **Действие:** `stack.Push('(')`
- **Логика:** Это "начало изоляции". Всё, что произойдет дальше, не должно взаимодействовать с тем, что было до скобки, пока мы её не закроем.

#### **Ситуация 3: Токен — Закрывающая скобка )**

- **Действие:**
    1. Запускаем цикл: `while (stack.Peek() != '(')`
    2. Внутри цикла: `output.Add(stack.Pop())`. (Перекладываем операторы из стека в выходную строку).
    3. **ВАЖНО:** Если стек опустел, а `(` так и не нашли — **Ошибка: Пропущенная скобка**.
    4. После цикла: `stack.Pop()`. Мы **удаляем** открывающую скобку из стека, но **НЕ** пишем её в `output`. Скобки в ОПН не нужны, они своё отработали.
        

#### **Ситуация 4: Токен — Оператор (op1)**

Пусть текущий оператор из входной строки — это `op1`.

- **Действие:**
    1. Смотрим на верхушку стека `(op2 = stack.Peek())`.
    2. Проверяем условие цикла **WHILE**:
        - Стек не пуст.
        - На вершине стека **НЕ** открывающая скобка (.
        - **Приоритет(op2) >= Приоритет(op1)**.  
            (Перевод: Если в стеке лежит оператор, который важнее или такой же по силе, как текущий — его надо выполнить первым).
            
    3. **Внутри цикла:** `output.Add(stack.Pop())`. Выкидываем "сильного" оператора из стека в результат.
    4. Повторяем проверку (п. 2) для нового оператора на вершине.
    5. **После цикла:** `stack.Push(op1)`. Текущий оператор занял своё место.

#### **Ситуация 5: Входная строка закончилась**
- **Действие:** `while (stack.Count > 0) -> output.Add(stack.Pop()).`
- **Логика:** Всё, что залежалось в стеке, вываливаем в конец строки.
- **ВАЖНО:** Если в этот момент встретили `(` — **Ошибка: Непарная скобка**.

### **Сухая трассировка (Dry Run)**

Пусть они прогонят это глазами.  
Выражение: `3 + 4 * 2`  
(Ожидаем: `3 4 2 * +`)

1. **Токен 3**: Число.
    
    - Output: 3
        
    - Stack: empty
        
2. **Токен +**: Оператор (приоритет 1).
    
    - Стек пуст -> Loop не работает.
        
    - Push +.
        
    - Output: 3
        
    - Stack: +
        
3. **Токен 4**: Число.
    
    - Output: 3 4
        
    - Stack: +
        
4. **Токен ***: Оператор (приоритет 2).
    
    - Смотрим в стек: там + (приоритет 1).
        
    - Условие Приоритет(+) >= Приоритет(*) -> 1 >= 2 -> **FALSE**.
        
    - Loop не работает. Мы не можем выгнать плюс, он слабее.
        
    - Push *.
        
    - Output: 3 4
        
    - Stack: + * (Звездочка легла поверх плюса, она выполнится первой)
        
5. **Токен 2**: Число.
    
    - Output: 3 4 2
        
    - Stack: + *
        
6. **Конец строки**:
    
    - Pop * -> Output.
        
    - Pop + -> Output.
        
    - Итог: 3 4 2 * +
        

---


### **Трассировка сложная (где они лажают)**

Выражение: `3 * 4 + 2`  
(Ожидаем: `3 4 * 2 +`, потому что умножение раньше)

1. ... (пропускаем начало, дошли до плюса) ...
    
    - Output: 3 4
        
    - Stack: * (приоритет 2)
        
2. **Токен +**: Оператор (приоритет 1).
    
    - Смотрим в стек: там * (приоритет 2).
        
    - Условие Приоритет(*) >= Приоритет(+) -> 2 >= 1 -> **TRUE**.
        
    - **Pop *** -> Output.
        
    - Output: 3 4 *
        
    - Stack: empty
        
    - Loop кончился (стек пуст).
        
    - **Push +**.
        
    - Stack: +
        
3. **Токен 2**:
    
    - Output: 3 4 * 2
        
    - Stack: +
        
4. **Конец**:
    
    - Pop +
        
    - Итог: 3 4 * 2 +
        

---