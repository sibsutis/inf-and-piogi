 ## «Моделирование работы 8-битного АЛУ (Арифметико-логического устройства)»

**Цель:** Получить практическое понимание принципов работы процессора с двоичными числами на низком уровне. В рамках работы предстоит реализовать полный цикл сложения двух целых чисел: от преобразования в двоичный код до побитового сложения и обратной конвертации. Результатом станет единый работающий механизм — простейший 8-битный калькулятор.

**Общая идея:** Вы напишете набор статических методов, которые будут выполнять роль компонентов процессора. Программа будет запрашивать у пользователя два числа, преобразовывать их в 8-битное представление, выполнять операцию двоичного сложения, конвертировать результат обратно в десятичную систему и выводить подробный отчет о проделанной работе. Это позволит наглядно увидеть процессы, происходящие на аппаратном уровне компьютера.

---

### **Задание:**

Все создаваемые функции должны быть объявлены как `static`. В качестве "массива битов" следует использовать `bool[]`, так как это является более эффективным с точки зрения логики и использования памяти для хранения бинарных данных (`true` — это `1`, `false` — это `0`).

#### **Часть 1. Инструменты (Конвертеры)**

Этот блок функций отвечает за преобразование данных между десятичной и двоичной системами счисления.

1.  **`static bool[] IntToBin(int n)`**
    *   Принимает целое число в диапазоне от -128 до 127.
    *   Возвращает массив `bool[8]`, содержащий его двоичное представление.
    *   Для отрицательных чисел должен использоваться **дополнительный код** (см. справочный материал).
    *   *Подсказка:* для реализации дополнительного кода удобно создать две вспомогательные функции:
        *   `static bool[] Invert(bool[] bits)` — инвертирует все значения в массиве (`true` -> `false`, `false` -> `true`).
        *   `static bool[] AddOne(bool[] bits)` — реализует операцию прибавления единицы к двоичному числу, представленному в массиве.

2.  **`static int BinToInt(bool[] bits)`**
    *   Принимает массив `bool[8]`.
    *   Возвращает целое число, которое представляет данный двоичный код.
    *   Должен корректно обрабатывать отрицательные числа в дополнительном коде (если старший бит — `true`).

3.  **`static string BinToStr(bool[] bits)`**
    *   Принимает массив `bool[8]`.
    *   Возвращает строковое представление двоичного кода для вывода на экран (например, "11111001").

#### **Часть 2. Вычислительное ядро (Арифметический блок)**

Это центральная часть калькулятора, отвечающая за выполнение арифметических операций.

1.  **`static bool[] AddBinary(bool[] a, bool[] b)`**
    *   Принимает на вход два массива `bool[8]`.
    *   Возвращает новый массив `bool[8]`, являющийся результатом их **побитового сложения**.
    *   Необходимо реализовать логику сложения "в столбик", включая перенос единицы в старший разряд (см. справочный материал).

#### **Часть 3. Сборка (Главный метод `Main`)**

На этом этапе все разработанные компоненты объединяются в единую программу.

Метод `Main` должен выполнять следующий сценарий:
1.  Запросить у пользователя первое число (`int a`).
2.  Запросить второе число (`int b`).
3.  Преобразовать `a` в двоичный массив `bool[] bin_a` с помощью `IntToBin`.
4.  Преобразовать `b` в двоичный массив `bool[] bin_b` с помощью `IntToBin`.
5.  Сложить `bin_a` и `bin_b` с помощью `AddBinary`, получив `bool[] sum_bin`.
6.  Преобразовать `sum_bin` обратно в число `int sum_int` с помощью `BinToInt`.
7.  Вывести на экран подробный отчет:
    *   Число `a` в двоичном виде (используя `BinToStr`).
    *   Число `b` в двоичном виде.
    *   Их двоичную сумму.
    *   Итоговое уравнение в десятичной системе, например: `5 + (-7) = -2`.
    *   Добавить строку для верификации результата: `Console.WriteLine($"Проверка C#: {a + b}")`, чтобы убедиться в корректности вычислений.

#### **Пример работы программы:**

```
Введите первое число от -128 до 127: 5
Введите второе число от -128 до 127: -7

Число 1 (5):    00000101
Число 2 (-7):   11111001
-------------------------
Сумма (двоич.): 11111110

Результат: 5 + (-7) = -2
Проверка C#: -2. Все сходится!
```
---

### **Файл 2: Справочная информация**

---

# Справочная информация

#### **Алгоритм: Десятичное число -> Двоичный код (Прямое преобразование)**

*   **Если число положительное (или 0):**
    Применяется стандартный алгоритм деления на 2. Остатки от деления, записанные в обратном порядке, формируют двоичное число. Результат дополняется слева нулями до 8 разрядов.
    *   *Пример:* `13 -> 1101 -> 00001101`

*   **Если число отрицательное (Дополнительный код):**
    Это стандартный метод представления отрицательных чисел в компьютерах.
    1.  Возьмите модуль числа (для `-13` это `13`).
    2.  Переведите его в двоичный код, как положительное: `13 -> 00001101`.
    3.  **Инвертируйте** все биты (прямой код -> обратный код): `00001101 -> 11110010`.
    4.  **Прибавьте единицу** к результату: `11110010 + 1 -> 11110011`. Это и есть двоичное представление числа `-13`.

#### **Алгоритм: Двоичный код -> Десятичное число (Обратное преобразование)**

*   **Определите знак числа по старшему (левому) биту:**
    *   Если `0` (`false`) — число положительное.
    *   Если `1` (`true`) — число отрицательное.

*   **Если число положительное:**
    Вычисляется как сумма степеней двойки. Двигаясь справа налево, каждый бит `1` добавляет `2^i` к сумме, где `i` — его позиция, начиная с 0.

*   **Если число отрицательное:**
    Применяется алгоритм, обратный получению дополнительного кода.
    1.  **Отнимите единицу** от двоичного кода: `11110011 - 1 -> 11110010`.
    2.  **Инвертируйте** все биты: `11110010 -> 00001101`.
    3.  **Переведите результат** как положительное число: `00001101 -> 13`.
    4.  **Добавьте знак минуса** к результату: `-13`.

#### **Алгоритм: Двоичное сложение (для `AddBinary`)**

Итерация по массивам производится справа налево (от индекса `7` до `0`). Для хранения переноса из младшего разряда в старший используется дополнительная переменная (`bool carry = false`).

Для каждой `i`-ой пары битов `a[i]`, `b[i]` и значения `carry`:
*   `0 + 0 + (перенос 0) = 0`, новый перенос `0`.
*   `0 + 1 + (перенос 0) = 1`, новый перенос `0`.
*   `1 + 1 + (перенос 0) = 0`, новый перенос `1`.
*   `0 + 0 + (перенос 1) = 1`, новый перенос `0`.
*   `0 + 1 + (перенос 1) = 0`, новый перенос `1`.
*   `1 + 1 + (перенос 1) = 1`, новый перенос `1`.

Ваша задача — реализовать эту логику в цикле. (Переполнение, выходящее за 8-й бит, игнорируется, что является стандартным поведением для целочисленной арифметики фиксированной разрядности).