 ## Введение

В данном разделе показан пример более гибкой вариативности выбора фильтра. Если вы полностью разобрались с делегатами, классами и 3ей и 4ой лабораторной работой - можете выполнить это дополнительное задание.

## Суть

Если вдруг вы обратили внимание, то большая часть наших фильтров имеет схожую сигнатуру.
![[laba4_signature_sample.png]]

В прошлой лабораторной работе, в качестве одного из аргументов функции `Filter` мы передавали делегат. Так как у части наших фильтров для изображения сигнатура выглядит как `void MethodName(Image img)`, эти фильтры могут быть добавлены в один словарь. 

Пример реализации через словарь:

Нам нужно создать подходящий под сигнатуру методов тип делегата:

```csharp
// Это можно объявить прямо в файле Program.cs, над классом Program
public delegate void ImageFilterDelegate(Image image);
```

Далее мы можем создать словарь, у которого ключом будет название метода (`string`), а значением будет метод (`ImageFilterDelegate`).
Создание словаря с ссылками на метод:
```csharp
var availableFilters = new Dictionary<string, ImageFilterDelegate> { 
	{ "invert", ImageFilters.Invert }, 
	{ "grayscale", ImageFilters.Grayscale }, 
	// Чтобы добавить новый, просто пишем его имя
	{ "sepia", ImageFilters.Sepia } 
};
```

Для методов с отличающейся сигнатурой (например: `AdjustBrightness(Image img, int value)`) можно создать метод с сигнатурой делегата (`void ApplyAdjustBrightness(Image img)`). Этот новый метод будет вызывать метод `AdjustBrightness`, передавать туда `img` из аргумента, а значение яркости нужно спарсить из консоли. 

Наше допущение:
Предполагается, если пользователь ввел название метода для яркости, то он введет четвертый аргумент значения. Его нужно будет получить из `args` при вызове `ApplyAdjustBrightness`.







Думайте...
